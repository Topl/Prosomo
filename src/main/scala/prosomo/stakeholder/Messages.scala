package prosomo.stakeholder

import akka.actor.ActorPath
import akka.util.Timeout
import prosomo.cases._
import prosomo.history.BlockStorage
import prosomo.primitives.{Mac, Parameters}
import scala.concurrent.Await
import scala.math.BigInt

/**
  * AMS 2020:
  * Local Akka message passing routines using ActorRefWrapper,
  * Provides some utilities for coordinator to collect info about state from Stakeholders
  */

trait Messages extends Members {
  import Parameters._

  /**
    * Signed data message for verification between holders
    * @param data any data
    * @param id session id
    * @param sk_sig sig private key
    * @param pk_sig sig public key
    * @return signed mac
    */
  def signMac(data: Hash, id:Sid, sk_sig: PrivateKey, pk_sig: PublicKey): Mac = {
    Mac(data,id,sig.sign(sk_sig,data.data++id.data),pk_sig)
  }

  /**
    * verify a mac generated by a remote holder
    * @param mac message authentication primitive
    * @return
    */
  def verifyMac(input:Hash, mac:Mac): Boolean = {
    mac.verify(input,sig,serializer)
  }


  /**
    * picks set of gossipers randomly
    * @param id self ref not to include
    * @param h list of holders
    * @return list of gossipers
    */
  def gossipSet(id:ActorPath,h:List[ActorRefWrapper]):List[ActorRefWrapper] = {
    var out:List[ActorRefWrapper] = List()
    for (holder <- rng.shuffle(h)) {
      if (holder.path != id && out.length < numGossipers) {
        out = holder::out
      }
    }
    out
  }

  /**
    * Sends command to one of the stakeholders
    * @param ref actor list
    * @param command object to be sent
    */
  def send(sender:ActorRefWrapper, ref:ActorRefWrapper, command: Any): Unit = {
    if (useRouting && !useFencing) {
      if (ref.remote) {
        routerRef ! MessageFromLocalToRemote(sender,ref.path, command)
      } else {
        routerRef ! MessageFromLocalToLocal(sender, ref, command)
      }
    } else if (useFencing) {
      routerRef ! MessageFromLocalToLocalId(BigInt(fch.hash(rng.nextString(64))),sender,ref,command)
    } else {
      ref ! command
    }
  }

  /**
    * Sends commands one by one to list of stakeholders
    * @param holders actor list
    * @param command object to be sent
    */
  def send(sender:ActorRefWrapper, holders:List[ActorRefWrapper], command: Any): Unit = {
    for (holder <- holders){
      if (useRouting && !useFencing) {
        if (holder.remote) {
          routerRef ! MessageFromLocalToRemote(sender,holder.path, command)
        } else {
          routerRef ! MessageFromLocalToLocal(sender, holder, command)
        }
      } else if (useFencing) {
        routerRef ! MessageFromLocalToLocalId(BigInt(fch.hash(rng.nextString(64))),sender,holder,command)
      } else {
        holder ! command
      }
    }
  }

  /**
    * Sends commands one by one to list of stakeholders
    * @param holders actor list
    * @param command object to be sent
    */
  def sendAssertDone(holders:List[ActorRefWrapper], command: Any): Unit = {
    for (holder <- holders){
      implicit val timeout:Timeout = Timeout(waitTime)
      val future = holder ? command
      val result = Await.result(future, timeout.duration)
      assert(result == "done")
    }
  }

  /**
    * Sends command to stakeholder and waits for response
    * @param holder to send to
    * @param command any command
    */
  def sendAssertDone(holder:ActorRefWrapper, command: Any): Unit = {
    implicit val timeout:Timeout = Timeout(waitTime)
    val future = holder ? command
    val result = Await.result(future, timeout.duration)
    assert(result == "done")
  }

  /**
    * returns map of gossipers to coordinator
    * @param holders to send to
    * @return map of actor ref to its list of gossipers
    */
  def getGossipers(holders:List[ActorRefWrapper]):Map[ActorRefWrapper,List[ActorRefWrapper]] = {
    var gossipersMap:Map[ActorRefWrapper,List[ActorRefWrapper]] = Map()
    for (holder <- holders){
      implicit val timeout:Timeout = Timeout(waitTime)
      val future = holder ? RequestGossipers
      val result = Await.result(future, timeout.duration)
      result match {
        case value:GetGossipers =>
          gossipersMap += (holder->value.list)
      }
    }
    gossipersMap
  }

  /**
    * returns the staking state to the coordinator
    * @param holder holder to return
    * @return
    */
  def getStakingState(holder:ActorRefWrapper):State = {
    implicit val timeout:Timeout = Timeout(waitTime)
    val future = holder ? RequestState
    val result = Await.result(future, timeout.duration)
    result match {
      case value:GetState =>
        value.s
    }
  }

  /**
    * sets the local chain history and block data to the holders
    * @param holder actor to get data from
    */
  def blockTree(holder:ActorRefWrapper): Unit = {
    implicit val timeout:Timeout = Timeout(waitTime)
    val future = holder ? RequestBlockTree
    val result = Await.result(future, timeout.duration)
    result match {
      case value:GetBlockTree =>
        value.t match {
          case _:BlockStorage => blocks
          case _ => println("error")
        }
        value.h match {
          //case h:SlotHistoryStorage => chainHistory.copy(h)
          case _ => //println("error")
        }
      case _ => println("error")
    }
  }

  def getPositionData(router:ActorRefWrapper):(Map[ActorRefWrapper,(Double,Double)],Map[(ActorRefWrapper,ActorRefWrapper),Long]) = {
    implicit val timeout:Timeout = Timeout(waitTime)
    val future = router ? RequestPositionData
    val result = Await.result(future, timeout.duration)
    result match {
      case value:GetPositionData => value.s
    }
  }
}
